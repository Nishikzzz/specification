"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var Field_1 = require("./Field");
var _1 = require("../../utils/");
// TODO: refactor this model, maybe use getters instead of copying all the values
var SchemaModel = /** @class */ (function () {
    /**
     * @param isChild if schema discriminator Child
     * When true forces dereferencing in allOfs even if circular
     */
    function SchemaModel(parser, schemaOrRef, $ref, options, isChild) {
        if (isChild === void 0) { isChild = false; }
        this.options = options;
        this.typePrefix = '';
        this.isCircular = false;
        this.activeOneOf = 0;
        this._$ref = schemaOrRef.$ref || $ref || '';
        this.rawSchema = parser.deref(schemaOrRef);
        this.schema = parser.mergeAllOf(this.rawSchema, this._$ref, isChild);
        this.init(parser, isChild);
        parser.exitRef(schemaOrRef);
        for (var _i = 0, _a = this.schema.parentRefs || []; _i < _a.length; _i++) {
            var parent$ref = _a[_i];
            // exit all the refs visited during allOf traverse
            parser.exitRef({ $ref: parent$ref });
        }
    }
    /**
     * Set specified alternative schema as active
     * @param idx oneOf index
     */
    SchemaModel.prototype.activateOneOf = function (idx) {
        this.activeOneOf = idx;
    };
    SchemaModel.prototype.init = function (parser, isChild) {
        var schema = this.schema;
        this.isCircular = schema['x-circular-ref'];
        this.title =
            schema.title || (_1.isNamedDefinition(this._$ref) && _1.JsonPointer.baseName(this._$ref)) || '';
        this.description = schema.description || '';
        this.type = schema.type || _1.detectType(schema);
        this.format = schema.format;
        this.nullable = !!schema.nullable;
        this.enum = schema.enum || [];
        this.example = schema.example;
        this.deprecated = !!schema.deprecated;
        this.pattern = schema.pattern;
        this.constraints = _1.humanizeConstraints(schema);
        this.displayType = this.type;
        this.isPrimitive = _1.isPrimitiveType(schema);
        this.default = schema.default;
        this.readOnly = !!schema.readOnly;
        this.writeOnly = !!schema.writeOnly;
        if (this.isCircular) {
            return;
        }
        if (!isChild && schema.discriminator !== undefined) {
            this.initDiscriminator(schema, parser);
            return;
        }
        if (schema.oneOf !== undefined) {
            this.initOneOf(schema.oneOf, parser);
            this.oneOfType = 'One of';
            if (schema.anyOf !== undefined) {
                console.warn("oneOf and anyOf are not supported on the same level. Skipping anyOf at " + this._$ref);
            }
            return;
        }
        if (schema.anyOf !== undefined) {
            this.initOneOf(schema.anyOf, parser);
            this.oneOfType = 'Any of';
            return;
        }
        if (this.type === 'object') {
            this.fields = buildFields(parser, schema, this._$ref, this.options);
        }
        else if (this.type === 'array' && schema.items) {
            this.items = new SchemaModel(parser, schema.items, this._$ref + '/items', this.options);
            this.displayType = this.items.displayType;
            this.typePrefix = this.items.typePrefix + 'Array of ';
            this.isPrimitive = this.items.isPrimitive;
            if (this.example === undefined && this.items.example !== undefined) {
                this.example = [this.items.example];
            }
            if (this.items.isPrimitive) {
                this.enum = this.items.enum;
            }
        }
    };
    SchemaModel.prototype.initOneOf = function (oneOf, parser) {
        var _this = this;
        this.oneOf = oneOf.map(function (variant, idx) {
            return new SchemaModel(parser, {
                // merge base schema into each of oneOf's subschemas
                allOf: [variant, __assign({}, _this.schema, { oneOf: undefined, anyOf: undefined })],
            }, _this._$ref + '/oneOf/' + idx, _this.options);
        });
        this.displayType = this.oneOf.map(function (schema) { return schema.displayType; }).join(' or ');
    };
    SchemaModel.prototype.initDiscriminator = function (schema, parser) {
        var _this = this;
        this.discriminatorProp = schema.discriminator.propertyName;
        var derived = parser.findDerived((schema.parentRefs || []).concat([this._$ref]));
        if (schema.oneOf) {
            for (var _i = 0, _a = schema.oneOf; _i < _a.length; _i++) {
                var variant = _a[_i];
                if (variant.$ref === undefined) {
                    continue;
                }
                var name_1 = _1.JsonPointer.dirName(variant.$ref);
                derived[variant.$ref] = name_1;
            }
        }
        var mapping = schema.discriminator.mapping || {};
        for (var name_2 in mapping) {
            derived[mapping[name_2]] = name_2;
        }
        var refs = Object.keys(derived);
        this.oneOf = refs.map(function (ref) {
            var innerSchema = new SchemaModel(parser, parser.byRef(ref), ref, _this.options, true);
            innerSchema.title = derived[ref];
            return innerSchema;
        });
    };
    __decorate([
        mobx_1.observable
    ], SchemaModel.prototype, "activeOneOf", void 0);
    __decorate([
        mobx_1.action
    ], SchemaModel.prototype, "activateOneOf", null);
    return SchemaModel;
}());
exports.SchemaModel = SchemaModel;
function buildFields(parser, schema, $ref, options) {
    var props = schema.properties || {};
    var additionalProps = schema.additionalProperties;
    var defaults = schema.default || {};
    var fields = Object.keys(props || []).map(function (fieldName) {
        var required = schema.required === undefined ? false : schema.required.indexOf(fieldName) > -1;
        return new Field_1.FieldModel(parser, {
            name: fieldName,
            required: required,
            schema: __assign({}, props[fieldName], { default: props[fieldName].default || defaults[fieldName] }),
        }, $ref + '/properties/' + fieldName, options);
    });
    if (options.requiredPropsFirst) {
        _1.sortByRequired(fields, schema.required);
    }
    if (typeof additionalProps === 'object') {
        fields.push(new Field_1.FieldModel(parser, {
            name: '[property name] *',
            required: false,
            schema: additionalProps,
        }, $ref + '/additionalProperties', options));
    }
    return fields;
}
//# sourceMappingURL=Schema.js.map