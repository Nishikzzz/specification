#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const server_1 = require("react-dom/server");
const styled_components_1 = require("styled-components");
const http_1 = require("http");
const zlib = require("zlib");
const path_1 = require("path");
// @ts-ignore
const _1 = require("../");
const fs_1 = require("fs");
const yargs = require("yargs");
yargs
    .command('serve [spec]', 'start the server', yargs => {
    yargs.positional('spec', {
        describe: 'path or URL to your spec',
    });
    yargs.option('s', {
        alias: 'ssr',
        describe: 'Enable server-side rendering',
        type: 'boolean',
    });
    yargs.option('p', {
        alias: 'port',
        type: 'number',
        default: 8080,
    });
    yargs.option('w', {
        alias: 'watch',
        type: 'boolean',
    });
    yargs.demandOption('spec');
    return yargs;
}, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        yield serve(argv.port, argv.spec, { ssr: argv.ssr, watch: argv.watch });
    }
    catch (e) {
        console.log(e.message);
    }
}))
    .command('bundle [spec]', 'bundle spec into zero-dependency HTML-file', yargs => {
    yargs.positional('spec', {
        describe: 'path or URL to your spec',
    });
    yargs.option('o', {
        describe: 'Output file',
        alias: 'output',
        type: 'number',
        default: 'redoc-static.html',
    });
    yargs.option('cdn', {
        describe: 'Do not include ReDoc source code into html page, use link to CDN instead',
        type: 'boolean',
        default: false,
    });
    yargs.demandOption('spec');
    return yargs;
}, (argv) => __awaiter(this, void 0, void 0, function* () {
    try {
        yield bundle(argv.spec, { ssr: true, output: argv.o, cdn: argv.cdn });
    }
    catch (e) {
        console.log(e.message);
    }
}))
    .demandCommand().argv;
function serve(port, pathToSpec, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let spec = yield _1.loadAndBundleSpec(pathToSpec);
        let pageHTML = yield getPageHTML(spec, pathToSpec, options);
        const server = http_1.createServer((request, response) => {
            console.time('GET ' + request.url);
            if (request.url === '/redoc.standalone.js') {
                respondWithGzip(fs_1.createReadStream('bundles/redoc.standalone.js', 'utf8'), request, response, {
                    'Content-Type': 'application/javascript',
                });
            }
            else if (request.url === '/') {
                respondWithGzip(pageHTML, request, response);
            }
            else if (request.url === '/spec.json') {
                const specStr = JSON.stringify(spec, null, 2);
                respondWithGzip(specStr, request, response, {
                    'Content-Type': 'application/json',
                });
            }
            else {
                response.writeHead(404);
                response.write('Not found');
                response.end();
            }
            console.timeEnd('GET ' + request.url);
        });
        console.log();
        server.listen(port, () => console.log(`Server started: http://127.0.0.1:${port}`));
        if (options.watch && fs_1.existsSync(pathToSpec)) {
            fs_1.watch(pathToSpec, debounce((event, filename) => __awaiter(this, void 0, void 0, function* () {
                if (event === 'change' || (event === 'rename' && fs_1.existsSync(filename))) {
                    console.log(`${pathToSpec} changed, updating docs`);
                    try {
                        spec = yield _1.loadAndBundleSpec(pathToSpec);
                        pageHTML = yield getPageHTML(spec, pathToSpec, options);
                        console.log('Updated successfully');
                    }
                    catch (e) {
                        console.error('Error while updating: ', e.message);
                    }
                }
            }), 2200));
            console.log(`ðŸ‘€  Watching ${pathToSpec} for changes...`);
        }
    });
}
function bundle(pathToSpec, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const spec = yield _1.loadAndBundleSpec(pathToSpec);
        const pageHTML = yield getPageHTML(spec, pathToSpec, Object.assign({}, options, { ssr: true }));
        fs_1.writeFileSync(options.output, pageHTML);
        const sizeInKb = Math.ceil(Buffer.byteLength(pageHTML) / 1024);
        console.log(`\nðŸŽ‰ bundled successfully in: ${options.output} (${sizeInKb} kB)`);
    });
}
function getPageHTML(spec, pathToSpec, { ssr, cdn }) {
    return __awaiter(this, void 0, void 0, function* () {
        let html, css, state;
        let redocStandaloneSrc;
        if (ssr) {
            console.log('Prerendering docs');
            let store = yield _1.createStore(spec, pathToSpec);
            const sheet = new styled_components_1.ServerStyleSheet();
            html = server_1.renderToString(sheet.collectStyles(React.createElement(_1.Redoc, { store })));
            css = sheet.getStyleTags();
            state = yield store.toJS();
            if (!cdn) {
                redocStandaloneSrc = fs_1.readFileSync(path_1.resolve(__dirname, '../bundles/redoc.standalone.js'));
            }
        }
        return `<html>
  <head>
    <meta charset="utf8" />
    <title>ReDoc</title>
    <!-- needed for adaptive design -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body {
        padding: 0;
        margin: 0;
      }
    </style>
    ${ssr
            ? cdn
                ? '<script src="https://unpkg.com/redoc@next/bundles/redoc.standalone.js"></script>'
                : `<script>${redocStandaloneSrc}</script>`
            : `<script src="redoc.standalone.js"></script>`}
    <link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700" rel="stylesheet">
    ${(ssr && css) || ''}
  </head>
  <body>
  <script>
      document.addEventListener('DOMContentLoaded', function() {
        ${(ssr && `const state = ${JSON.stringify(state)};`) || ''}
        var container = document.getElementById('redoc');
        Redoc.${ssr ? 'hydrate(state, container);' : 'init("spec.json", {}, container)'};
      });
      </script>
    <div id="redoc">${(ssr && html) || ''}</div>
  </body>
  </html>`;
    });
}
// credits: https://stackoverflow.com/a/9238214/1749888
function respondWithGzip(contents, request, response, headers = {}) {
    let compressedStream;
    const acceptEncoding = request.headers['accept-encoding'] || '';
    if (acceptEncoding.match(/\bdeflate\b/)) {
        response.writeHead(200, Object.assign({}, headers, { 'content-encoding': 'deflate' }));
        compressedStream = zlib.createDeflate();
    }
    else if (acceptEncoding.match(/\bgzip\b/)) {
        response.writeHead(200, Object.assign({}, headers, { 'content-encoding': 'gzip' }));
        compressedStream = zlib.createGzip();
    }
    else {
        response.writeHead(200, headers);
        if (typeof contents === 'string') {
            response.write(contents);
            response.end();
        }
        else {
            contents.pipe(response);
        }
        return;
    }
    if (typeof contents === 'string') {
        compressedStream.write(contents);
        compressedStream.pipe(response);
        compressedStream.end();
        return;
    }
    else {
        contents.pipe(compressedStream).pipe(response);
    }
}
function debounce(callback, time) {
    let interval;
    return (...args) => {
        clearTimeout(interval);
        interval = setTimeout(() => {
            interval = null;
            callback(...args);
        }, time);
    };
}
